39. Combination Sum (DFS + backtracking and to handle duplicate require add start index to tracking but no need to +1 in recursive since it allows repeat using same element)
40. Combination Sum II (DFS + backtracking and sort with addtional condition to skip duplicated combinations required)
216. Combination Sum III (DFS + backtracking and manually create the combination set)
377.Combination Sum IV (DFS with memoization + Follow up with negative number handle)
64.Minimum Path Sum (DP(backtracking) with memoization)
638.Shopping Offers (DFS with memoization)
935.Knight Dialer (DFS with memoization)
139.Word Break (DFS with memoization)
78.Subsets (backtrack
            // base condition
            if(index >= nums.length) {
                return;
            }
            // Logic branch-1: Not add nums[index] into current subset and its inheritance chain sets
            helper(result, tmp, nums, index + 1);)
            // Create one subset contain nums[index]
            List<Integer> oneSubset = new ArrayList<Integer>(tmp);
            oneSubset.add(nums[index]);
            result.add(oneSubset);
            // Logic branch-2: Add nums[index] into current subset and its inheritance chain sets
            helper(result, oneSubset, nums, index + 1);)
90. Subsets II (backtrack but sort first + skip duplicate numbers)
46. Permutations (DFS + backtracking checking already existing value and always start from index = 0 to build)
47. Permutations II (DFS + backtracking with boolean array to assure same value after permutation keep the same order)
131. Palindrome Partitioning (DFS + backtracking)
79. Word Search (
public boolean dfs(char[][] board, String word, int index, int rowIndex, int columnIndex, boolean[][] visited) {
        // Base case, when index reach the end, and not return as false means we found the word in board
        if(index == word.length()) {
            return true;
        } 
        
        // Boundary check must before conditional check, otherwise will throw out ArrayOutOfBound exception
        if(rowIndex < 0 || rowIndex > board.length - 1 || columnIndex < 0 || columnIndex > board[0].length - 1) {
            return false;
        }
        
        // Condition to break out current level loop as this item on board is already visited
        if(visited[rowIndex][columnIndex]) {
            return false;
        }
        
        // Condition to break out current level loop as this item on board not match the required character
        if(board[rowIndex][columnIndex] != word.charAt(index)) {
            return false;
        }
        
        // Record current item in board has been visited before looply detect next character
        // in potential item
        visited[rowIndex][columnIndex] = true;
        
        // Detect potential item for next character(index + 1) on right/left/up/down four directions 
        boolean result = dfs(board, word, index + 1, rowIndex + 1, columnIndex, visited) ||
                         dfs(board, word, index + 1, rowIndex - 1, columnIndex, visited) ||
                         dfs(board, word, index + 1, rowIndex, columnIndex + 1, visited) ||
                         dfs(board, word, index + 1, rowIndex, columnIndex - 1, visited);
        
        // Restore the boolean tag for current item for next round detect
        visited[rowIndex][columnIndex] = false;
        
        return result;
    })
212. Word Search II (Trie + DFS + backtracking)
648. Replace Words (Trie)
979. Distribute Coins in Binary Tree (we have an excess of node.val + dfs(node.left) + dfs(node.right) - 1 coins at this node)
841. Keys and Rooms (When we enter a room, mark it as visited)
1026. Maximum Difference Between Node and Ancestor (Maintain min and max value at one time)
1020. Number of Enclaves (We flood-fill the land (change 1 to 0) from the boundary of the grid. Then, we count the remaining land.)
947. Most Stones Removed with Same Row or Column (Change based on Number of Islands, dfs + unionfind)
547. Friend Circles (Same as Number of Connected Components in an Undirected Graph)
490. The Maze (DFS with re-assign value to new variable recording start position in DFS recursion)
694. Number of Distinct Islands (DFS and choose base point and use set to check islands identical)
988. Smallest String Starting From Leaf (DFS should go from top-down only)
679. 24Game (ignore braces and implement back tracking by removing used elemnts)
688. Knight Probability in Chessboard (DFS memoization with 3-dimension array)
